#include "ModelRenderer.h"

#include <Scene/Model.h>

namespace Render
{
ImplementRTTI(Render::IModelRenderer, Render::IRenderer);

// Forward rendering:
// - Render solid objects to depth buffer, front to back (only if render to texture?)
// - Render atest objects to depth buffer, front to back (only if render to texture?)
// - Occlusion (against z-buffer filled by 1 and 2)
// - Render sky without zwrite and mb without ztest //???better to render sky after all other non-alpha/additive geometry?
// - Render terrain (lightmapped/unlit/...?) FTB //???render after all opaque except skybox?
// - Render opaque geometry (static, skinned, blended, envmapped) FTB
// - Render alpha-tested geometry (static, leaf, tree) FTB
// - Render alpha-blended geometry (alpha, alpha_soft, skinned_alpha, env_alpha, water) BTF
// - Render particles (alpha, then additive) BTF?
// - HDR

//!!!rendering front-to-back with existing z-buffer has no point!
//z-pass FtB has meaning!

void IModelRenderer::AddRenderObjects(const nArray<Scene::CRenderObject*>& Objects)
{
	for (int i = 0; i < Objects.Size(); ++i)
	{
		if (!Objects[i]->IsA(Scene::CModel::RTTI)) continue;
		Scene::CModel* pModel = (Scene::CModel*)Objects[i];
		if (!(pModel->Material->GetBatchType() & AllowedBatchTypes)) continue;

		// Docs: Also be aware that handles generated by different
		// instances of ID3DXEffect and ID3DXEffectCompiler will be different.
		// So can sort by tech directly, without sorting by shader

		//???remember in application, what constants are used in what techs? 2D table

		// Sorting:
		// Shader1 Tech1 Material1	Set tech and begin, set material vars
		// Shader1 Tech1 Material1	No changes
		// Shader1 Tech1 Material2	Set material vars
		// Shader1 Tech2 Material1	End, set tech and begin (OR CAN CHANGE TECH inside begin/end?)
		// Shader1 Tech2 Material2	Set material vars
		// Shader2 Tech1 Material1
		// Shader2 Tech2 Material1
		// Shader2 Tech3 Material1
		// Shader2 Tech3 Material2
		// Shader2 Tech3 Material2
		// Shader2 Tech3 Material3

		DWORD FeatFlags = pModel->FeatureFlags | pModel->Material->GetFeatureFlags();

		// Find desired tech

		// Model renderer will add some flags itself (forex Depth)

		Models.Append(pModel);
	}
}
//---------------------------------------------------------------------

// NB: It is overriden to empty method in CModelRendererNoLight
void IModelRenderer::AddLights(const nArray<Scene::CLight*>& Lights)
{
	pLights = &Lights;
	//for (int i = 0; i < Lights.Size(); ++i)
	//{
	//	// Perform something with lights or just store array ref
	//}
}
//---------------------------------------------------------------------

}